# Creating Routes


## Objectives

- Create restful routes
- Examine HTTP methods and status codes
- Understand request and response


## Class Resources

[RESTful routing - Slides](restful-routing.key)


## REST & Resourceful Routing

We are going to be following REST standards building this API.
With REST every resource in your application maps out to a route that can be accessed.
Think **User** resource with user routes, trips resource with routes for trips

## Resources

Below the setup code that we just discussed we're implementing our first resource:

```python

class MyObject(Resource):

    def post(self):
      #1
      new_myobject = request.json
      #2
      myobject_collection = app.db.myobjects
      #3
      result = myobject_collection.insert_one(new_myobject)
	  #4
      myobject = myobject_collection.find_one({"_id": ObjectId(result.inserted_id)})
	  #5
      return myobject

    def get(self, myobject_id):
      #6
      myobject_collection = app.db.myobjects
      #7
      myobject = myobject_collection.find_one({"_id": ObjectId(myobject_id)})

	  #8
      if myobject is None:
        response = jsonify(data=[])
        response.status_code = 404
        return response
      else:
        return myobject
```

This small starter project only has a single resource (MyObject). Most apps will define one resource for each entity that can be stored in the app (e.g. User, Post, etc.). The resource implements one method for each HTTP verb that is supported.

Let's take a look at the implementation in detail, starting with the post method. The post method is invoked to create a new instance of MyObject on the server. The client that calls this endpoint provides a JSON body as part of the HTTP request:


1. We access the JSON that the client provided through the request.json variable. The request variable is implicitly available through the request context.

2. We access the collection in which we will store the new object. Typically we create one collection per entitiy type (e.g. User, Post, etc.).

3. We insert the JSON document into the collection. MongoDB is schema free, this means we can store JSON of any arbitrary structure in this collection. In a more complex application you would might want to validate the JSON structure to a certain degree. For this application we will trust the client to provide the correctly structured information.

4. After inserting the document we retrieve the result. Then we use this result to fetch the inserted document from the collection using the find_one method. The find_one method takes a dictionary that describes the filter criteria for our documents (in this case documents with a specific id). The _id field is automatically maintained by MongoDB and stores the unique identifier for each document that is stored. Note that we need to wrap the result.inserted_id into an ObjectId type. The ObjectId type is not a string! If you try to compare it to a string you won't get any results.

5. We return the selected document to the client. Now the client will be able to retrieve the _id generated by MongoDB and will know which id is associated with the new document on the server.
The get method for MyObject is a little bit simpler:

6. We reference the myobjects collection from which we'll select the document that the client is trying to access.

7. We build a query based on the myobject_id that we have received as part of the client's request. Later you'll see how this argument is handed to the get method.

8. If we can't find a document with the provided id we return a 404 status code. If we found a document we return it to the client.

That's all the code that goes into implementing a very simple resource! For this application our server is just acting as a thin layer above the DB.


## Adding RESTful routes in Flask

The next important aspect of the starter project code is the mapping between routes and resources. A route defines a URL that can be called by a client application. Our simple server only has one route, here's the code that defines it:

```python
api.add_resource(MyObject, '/myobject/','/myobject/<string:myobject_id>')
```

The first parameter is the resource which we want ot map to a specific URL. Next, we have a collection of different URLs that map to that resource. For this application there are two different ways to call the myobject endpoint. The first one is /myobject/, without a specific object id. This endpoint is used to operate on the collection of myobjects. The second endpoint takes an object id, e.g. /myobject/2. This endpoint is used to operate on a specific myobject.

With this additional line of setup, our server will now know which class to call when a specific URL is requested by the client. Additionally the HTTP verb of the request (GET, POST, etc.) will be used to determine which method on that class should be called.


## Route types
### Nested Routes

When you have a collection of related resources as we do with users and trips, sometimes you want to nest one resource into another.

| Action  	| HTTP Verb 	| Path             	| Effect                           	        |
|---------	|-----------	|------------------	|-------------------------------------------|
| create  	| POST      	| /user/trips           	| Creates a new trip               	|
| index   	| GET       	| /user/trips           	| Shows/lists all trips            	|
| show    	| GET       	| /user/trips/<trip_id> 	| Shows a specific trip            	|
| update  	| PUT/PATCH 	| /user/trips/<trip_id> 	| Updates/replaces a specific trip 	|
| destroy 	| DELETE    	| /user/trips/<trip_id> 	| Deletes a specific trip          	|


## Additional Configuration

We have two additional configuration blocks in this starter project that I would like to discuss briefly. The first one configures a custom JSON serializer for our flask app:

```python
# provide a custom JSON serializer for flask_restful
@api.representation('application/json')
def output_json(data, code, headers=None):
    resp = make_response(JSONEncoder().encode(data), code)
    resp.headers.extend(headers or {})
    return resp
```

A JSON Encoder takes python objects and turns them into a JSON text representation. For this application we need a custom serializer, because the default serializer does not know how to handle MongoDB's ObjectIDs. A little earlier we discussed that an ObjectID is a specific type that is used to refer to a document in a MongoDB instance. This ObjectID isn't a string, so it cannot be serialized by Flask's default serializer.

With the lines above we install our custom encoder for any response that has the MIME type application/json (Read more about custom encoders here).

The code for our custom encoder lives in this file of the starter project: /utils/mongo_json_encoder.py - take a look at the implementation if you're curious about the implementation!

The last part of the source file is the standard boilerplate code for starting a flask server:

```python
if __name__ == '__main__':
    # Turn this on in debug mode to get detailled information about request related exceptions: http://flask.pocoo.org/docs/0.10/config/
    app.config['TRAP_BAD_REQUEST_ERRORS'] = True
    app.run(debug=True)
```

## HTTP Status Codes and Responses

Full list of HTTP status codes:

http://www.restapitutorial.com/httpstatuscodes.html


## Challenges

1. Create a user Resource that responds to GET, PUT, POST, validate that the parameters sent to the route has a username, email and password in the json payload sent to your server. Send back 200 when parameters match, 400 (Bad request) if parameters don't match.


